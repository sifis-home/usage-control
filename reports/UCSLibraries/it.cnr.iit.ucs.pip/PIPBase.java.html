<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PIPBase.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">coverage</a> &gt; <a href="../index.html" class="el_bundle">UCSLibraries</a> &gt; <a href="index.source.html" class="el_package">it.cnr.iit.ucs.pip</a> &gt; <span class="el_source">PIPBase.java</span></div><h1>PIPBase.java</h1><pre class="source lang-java linenums">/*
 * CNR - IIT (2015-2016)
 *
 * @authors Fabio Bindi and Filippo Lauria
 */
package it.cnr.iit.ucs.pip;

import it.cnr.iit.ucs.constants.ENTITIES;
import it.cnr.iit.ucs.exceptions.PIPException;
import it.cnr.iit.ucs.message.attributechange.AttributeChangeMessage;
import it.cnr.iit.ucs.properties.components.PipProperties;
import it.cnr.iit.ucs.requestmanager.RequestManagerInterface;
import it.cnr.iit.utility.errorhandling.Reject;
import it.cnr.iit.xacml.Attribute;
import it.cnr.iit.xacml.Category;
import it.cnr.iit.xacml.DataType;
import oasis.names.tc.xacml.core.schema.wd_17.RequestType;

import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * General PIP abstract class
 *
 * @author Fabio Bindi and Filippo Lauria and Antonio La Marra and Alessandro Rosetti
 */
public abstract class PIPBase implements PIPCHInterface, PIPOMInterface {

    private RequestManagerInterface requestManager;

    /**
     * Map having the attributeId as key and an Attribute object as value
     */
<span class="fc" id="L37">    private final HashMap&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();</span>

    /**
     * List that stores the attributes on which a 'subscribe' has been performed
     */
<span class="fc" id="L42">    public final BlockingQueue&lt;Attribute&gt; subscriptions = new LinkedBlockingQueue&lt;&gt;();</span>

    // Whenever a PIP has to retrieve some information related to an attribute
    // that is stored inside the request, it has to know in advance all the
    // information to retrieve that attribute. E.g. if this PIP has to retrieve
    // information about the subject, it has to know in advance which is the
    // attribute id qualifying the subject, its category and the data-type used,
    // otherwise it is not able to retrieve the value of that attribute, hence it
    // would not be able to communicate with the AM properly
    /**
     * Map having attributeId as key and the expected category as value
     */
<span class="fc" id="L54">    public final Map&lt;String, Category&gt; expectedCategoryMap = new HashMap&lt;&gt;();</span>

    private final PipProperties properties;

<span class="fc" id="L58">    public PIPBase(PipProperties properties) {</span>
<span class="fc" id="L59">        Reject.ifNull(properties);</span>
<span class="fc" id="L60">        this.properties = properties;</span>
<span class="fc" id="L61">    }</span>


    public boolean init(PipProperties properties) {
        try {
<span class="nc bnc" id="L66" title="All 2 branches missed.">            for (Map&lt;String, String&gt; attributeMap : properties.getAttributes()) {</span>

<span class="nc" id="L68">                Attribute attribute = new Attribute();</span>
<span class="nc" id="L69">                buildAttribute(attribute, attributeMap);</span>

<span class="nc" id="L71">                addAttribute(attribute);</span>

                // timer for polling the value of the attribute
<span class="nc" id="L74">                PIPSubscriberTimer subscriberTimer = new PIPSubscriberTimer(this);</span>
<span class="nc" id="L75">                subscriberTimer.setRate(properties.getRefreshRate());</span>
<span class="nc" id="L76">                subscriberTimer.start();</span>
<span class="nc" id="L77">            }</span>
<span class="nc" id="L78">            return true;</span>
<span class="nc" id="L79">        } catch (Exception e) {</span>
<span class="nc" id="L80">            return false;</span>
        }
    }


    /**
     * Use the information in the PipProperties to build an attribute
     *
     * @param attribute    the attribute to build
     * @param attributeMap the part of the PipProperties representing an attribute
     */
    public void buildAttribute(Attribute attribute, Map&lt;String, String&gt; attributeMap) {
<span class="fc" id="L92">        String attributeId = attributeMap.get(PIPKeywords.ATTRIBUTE_ID);</span>
<span class="fc" id="L93">        attribute.setAttributeId(attributeId);</span>

<span class="fc" id="L95">        Category category = Category.toCATEGORY(attributeMap.get(PIPKeywords.CATEGORY));</span>
<span class="fc" id="L96">        attribute.setCategory(category);</span>

<span class="fc" id="L98">        DataType dataType = DataType.toDATATYPE(attributeMap.get(PIPKeywords.DATA_TYPE));</span>
<span class="fc" id="L99">        attribute.setDataType(dataType);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (attribute.getCategory() != Category.ENVIRONMENT) {</span>
<span class="fc" id="L102">            Category expectedCategory = Category.toCATEGORY(attributeMap.get(PIPKeywords.EXPECTED_CATEGORY));</span>
<span class="fc" id="L103">            Reject.ifNull(expectedCategory, &quot;missing expected category&quot;);</span>
<span class="fc" id="L104">            expectedCategoryMap.put(attribute.getAttributeId(), expectedCategory);</span>
        }
<span class="fc" id="L106">    }</span>


    /**
     * Performs the retrieve operation.
     * The retrieve operation is a very basic operation in which the PIP simply
     * asks the AttributeManager the value in which it is interested into. Once
     * that value has been retrieved, the PIP will fatten the request.
     *
     * @param request this is an in/out parameter
     */
    @Override
    public void retrieve(RequestType request) throws PIPException {
<span class="fc" id="L119">        Reject.ifNull(request);</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (Attribute attribute : getAttributes()) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (!isEnvironmentCategory(attribute)) {</span>
<span class="fc" id="L123">                addAdditionalInformation(request, attribute);</span>
            }
            try {
<span class="fc" id="L126">                String value = retrieve(attribute);</span>
<span class="fc" id="L127">                request.addAttribute(attribute, value);</span>
<span class="nc" id="L128">            } catch (Exception e) {</span>
                //TODO: handle exception
<span class="nc" id="L130">                System.err.println(e.getMessage());</span>
<span class="fc" id="L131">            }</span>
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">    }</span>


    /**
     * Performs the subscribe operation. The request passed as input is used
     * to retrieve the information related to either the subject, resource, or action.
     * The attributeId is used to select the right attribute from those this PIP
     * is monitoring.
     *
     * @param request     the XACML request containing at least subject-id, resource-id and action-id
     * @param attributeId the attributeId of the attribute we want this PIP to subscribe to.
     */
    @Override
    public void subscribe(RequestType request, String attributeId) {
<span class="nc" id="L147">        Reject.ifNull(request);</span>

<span class="nc" id="L149">        Attribute attribute = getAttributes().stream()</span>
<span class="nc" id="L150">                .filter(attr -&gt; attr.getAttributeId().equals(attributeId)).findAny().orElse(null);</span>
<span class="nc" id="L151">        Reject.ifNull(attribute);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (!isEnvironmentCategory(attribute)) {</span>
<span class="nc" id="L153">            addAdditionalInformation(request, attribute);</span>
        }
        try {
<span class="nc" id="L156">            String value = subscribe(attribute);</span>
<span class="nc" id="L157">            request.addAttribute(attribute, value);</span>
<span class="nc" id="L158">        } catch (Exception e) {</span>
            //TODO: handle exception
<span class="nc" id="L160">            System.err.println(e.getMessage());</span>
<span class="nc" id="L161">        }</span>
<span class="nc" id="L162">    }</span>


    /**
     * Performs the subscribe operation. This operation is very similar to the
     * retrieve operation. The only difference is that in this case we have to
     * signal to the thread in charge of performing the polling that it has to
     * poll a new attribute
     *
     * @param request IN/OUT parameter
     */
    @Override
    public void subscribe(RequestType request) throws PIPException {
<span class="fc" id="L175">        Reject.ifNull(request);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (Attribute attribute : getAttributes()) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (!isEnvironmentCategory(attribute)) {</span>
<span class="fc" id="L179">                addAdditionalInformation(request, attribute);</span>
            }
            try {
<span class="fc" id="L182">                String value = subscribe(attribute);</span>
<span class="fc" id="L183">                request.addAttribute(attribute, value);</span>
<span class="nc" id="L184">            } catch (Exception e) {</span>
                //TODO: handle exception
<span class="nc" id="L186">                System.err.println(e.getMessage());</span>
<span class="fc" id="L187">            }</span>
<span class="fc" id="L188">        }</span>
<span class="fc" id="L189">    }</span>


    /**
     * This is the function called by the context handler whenever we have a
     * remote retrieve request
     */
    @Override
    public String subscribe(Attribute attribute) throws PIPException {
<span class="fc" id="L198">        Reject.ifNull(attribute);</span>

<span class="fc" id="L200">        String value = retrieve(attribute);</span>
<span class="fc" id="L201">        addSubscription(attribute);</span>

<span class="fc" id="L203">        return value;</span>
    }


    /**
     * Add the attribute passed as argument to the list of subscriptions
     *
     * @param attribute the attribute to add to the list
     */
    public void addSubscription(Attribute attribute) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (!subscriptions.contains(attribute)) {</span>
<span class="fc" id="L214">            subscriptions.add(attribute);</span>
        }
<span class="fc" id="L216">    }</span>


    /**
     * Given a list of attributes as input, remove from the subscriptions list the attributes
     * that match.
     * For the environment attributes, only the attributeId must match in order for an attribute
     * to be removed from the subscriptions list.
     * For attributes of other categories, both the attributeId and the additionalInformation must
     * match in order for an attribute to be removed from the subscriptions list.
     * This is because, for example, the PIP could be monitoring the attributeId 'subject-role'
     * for the subject with subject-id 'User1' and for the subject with subject-id 'User2'.
     * The information 'User1' or 'User2' is contained within the additionalInformation field.
     *
     * @param unsubAttributes the list of attributes that must be unsubscribed
     */
    @Override
    public boolean unsubscribe(List&lt;Attribute&gt; unsubAttributes) throws PIPException {
<span class="fc" id="L234">        Reject.ifEmpty(unsubAttributes);</span>

<span class="fc" id="L236">        boolean atLeastOneAttributeRemoved = false;</span>

        // for each attribute to unsubscribe
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (Attribute attributeToUnsubscribe : unsubAttributes) {</span>

            // for each attribute the PIP is subscribed to
<span class="fc bfc" id="L242" title="All 2 branches covered.">            for (Attribute subscribedAttribute : subscriptions) {</span>

                // if the attributeId matches one of the attributes the PIP has an active subscription
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                if (subscribedAttribute.getAttributeId().equals(attributeToUnsubscribe.getAttributeId())) {</span>
                    // if the attribute is of category Environment,
                    // or if the additionalInformation matches
<span class="fc bfc" id="L248" title="All 2 branches covered.">                    if (subscribedAttribute.getCategory() == Category.ENVIRONMENT ||</span>
<span class="fc" id="L249">                            subscribedAttribute.getAdditionalInformation()</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                                    .equals(attributeToUnsubscribe.getAdditionalInformation())) {</span>
<span class="fc" id="L251">                        atLeastOneAttributeRemoved = removeAttribute(subscribedAttribute);</span>
<span class="fc" id="L252">                        break;</span>
                    }
                }
<span class="fc" id="L255">            }</span>
<span class="fc" id="L256">        }</span>
<span class="fc" id="L257">        return atLeastOneAttributeRemoved;</span>
    }


    /**
     * Retrieve the value of the
     */
    public void checkSubscriptions() {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (Attribute attribute : subscriptions) {</span>

            // first, get the old value as memorized in the attribute
<span class="fc" id="L268">            String oldValue = attribute.getAttributeValues(attribute.getDataType()).get(0);</span>
            //get(0) assumes that the attribute has only one value

            String value;
//            log.log( Level.INFO, &quot;Polling on value of the attribute &quot; + attribute.getAttributeId() + &quot; for change.&quot; );

            // then, retrieve the new value.
            //   Note that the retrieve method updates the attribute with the value just retrieved
            try {
<span class="fc" id="L277">                value = retrieve(attribute);</span>
<span class="nc" id="L278">            } catch (PIPException e) {</span>
<span class="nc" id="L279">                getLogger().log(Level.WARNING, &quot;Error reading attribute &quot;</span>
<span class="nc" id="L280">                        + attribute.getAttributeId() + e.getMessage());</span>
<span class="nc" id="L281">                continue;</span>
<span class="fc" id="L282">            }</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (!oldValue.equals(value)) { // if the attribute has changed</span>
<span class="fc" id="L285">                getLogger().log(Level.INFO,</span>
                        &quot;Attribute {0}={1}:{2} changed at {3}&quot;,
<span class="fc" id="L287">                        new Object[]{attribute.getAttributeId(), value,</span>
<span class="fc" id="L288">                                attribute.getAdditionalInformation(),</span>
<span class="fc" id="L289">                                System.currentTimeMillis()});</span>
<span class="fc" id="L290">                attribute.setValue(attribute.getDataType(), value);</span>
<span class="fc" id="L291">                notifyRequestManager(attribute);</span>
            }
<span class="fc" id="L293">        }</span>
<span class="fc" id="L294">    }</span>


    /**
     * Remove the attribute passed as argument from the list of subscriptions
     *
     * @param subscribedAttribute the attribute to remove from the list
     */
    private boolean removeAttribute(Attribute subscribedAttribute) {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (!subscriptions.remove(subscribedAttribute)) {</span>
<span class="nc" id="L304">            throw new IllegalStateException(&quot;Unable to remove attribute from list&quot;);</span>
        }
<span class="fc" id="L306">        return true;</span>
    }


    /**
     * Check if the attribute's category is 'environment'
     *
     * @param attribute the attribute to examine
     * @return true is the category of the attribute is 'environment',
     * false otherwise
     */
    public boolean isEnvironmentCategory(Attribute attribute) {
<span class="fc bfc" id="L318" title="All 2 branches covered.">        return attribute.getCategory() == Category.ENVIRONMENT;</span>
    }


    /**
     * Add information coming from the request to the attribute.
     * In particular, the attribute is added the value of either the 'subject-id',
     * the 'resource-id', or the 'action-id' attribute. This information
     * is stored in the additionalInformation field of the attribute.
     *
     * @param request   The XACML request
     * @param attribute the attribute to which the additionalInformation has to be set
     */
    private void addAdditionalInformation(RequestType request, Attribute attribute) {
<span class="fc" id="L332">        String filter = request.getAttributeValue(expectedCategoryMap.get(attribute.getAttributeId()));</span>
<span class="fc" id="L333">        attribute.setAdditionalInformation(filter);</span>
<span class="fc" id="L334">    }</span>


    @Override
    public final ArrayList&lt;String&gt; getAttributeIds() {
<span class="nc" id="L339">        return new ArrayList&lt;&gt;(attributesMap.keySet());</span>
    }

    @Override
    public final ArrayList&lt;Attribute&gt; getAttributes() {
<span class="fc" id="L344">        return new ArrayList&lt;&gt;(attributesMap.values());</span>
    }

    @Override
    public final HashMap&lt;String, Attribute&gt; getAttributesCharacteristics() {
<span class="nc" id="L349">        return attributesMap;</span>
    }

    @Override
    public RequestManagerInterface getRequestManager() {
<span class="fc" id="L354">        Reject.ifNull(requestManager, &quot;request manager is null&quot;);</span>
<span class="fc" id="L355">        return requestManager;</span>
    }

    @Override
    public void setRequestManager(RequestManagerInterface requestManager) {
<span class="fc" id="L360">        Reject.ifNull(requestManager);</span>
<span class="fc" id="L361">        this.requestManager = requestManager;</span>
<span class="fc" id="L362">    }</span>

    protected final boolean addAttribute(Attribute attribute) {
<span class="fc" id="L365">        Reject.ifNull(attribute);</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (attributesMap.containsKey(attribute.getAttributeId())) {</span>
<span class="nc" id="L367">            return false;</span>
        }
<span class="fc" id="L369">        attributesMap.put(attribute.getAttributeId(), attribute);</span>
<span class="fc" id="L370">        return true;</span>
    }


    /**
     * Send a message to the Request Manager to notify it that an attribute
     * value changed.
     *
     * @param attribute the attribute whose value changed
     */
    public void notifyRequestManager(Attribute attribute) {
<span class="fc" id="L381">        AttributeChangeMessage attrChangeMessage = new AttributeChangeMessage(ENTITIES.PIP.toString(), ENTITIES.CH.toString());</span>
<span class="fc" id="L382">        ArrayList&lt;Attribute&gt; attrList = new ArrayList&lt;&gt;(Arrays.asList(attribute));</span>
<span class="fc" id="L383">        attrChangeMessage.setAttributes(attrList);</span>
<span class="fc" id="L384">        getRequestManager().sendMessage(attrChangeMessage);</span>
<span class="fc" id="L385">    }</span>

    /**
     * Get the queue containing the subscriptions
     *
     * @return the queue containing the subscriptions
     */
    public BlockingQueue&lt;Attribute&gt; getSubscriptions() {
<span class="nc" id="L393">        return subscriptions;</span>
    }

    protected abstract Logger getLogger();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>